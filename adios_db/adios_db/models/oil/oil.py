"""
Main class that represents an oil record.

This maps to the JSON used in the DB

Having a Python class makes it easier to write importing, validating etc, code.
"""
import json

from dataclasses import dataclass, field

from ..common.utilities import dataclass_to_json

from .metadata import MetaData
from .sample import SampleList
from .version import Version, VersionError

from .validation.warnings import WARNINGS
from .validation.errors import ERRORS

ADIOS_DATA_MODEL_VERSION = Version(0, 10, 0)


@dataclass_to_json
@dataclass
class Oil:
    oil_id: str  # required
    adios_data_model_version: Version = ADIOS_DATA_MODEL_VERSION
    metadata: MetaData = field(default_factory=MetaData)
    sub_samples: SampleList = field(default_factory=SampleList)
    status: list = field(default_factory=list)
    permanent_warnings: list = field(default_factory=list)
    extra_data: dict = field(default_factory=dict)

    def __post_init__(self):
        '''
            Put any validation code here (__init__() is auto-generated by the
            dataclass decorator, and it will clobber any attempt to overload
            the __init__.)
        '''
        if self.oil_id == "":
            raise TypeError("You must supply a non-empty oil_id")
        elif not isinstance(self.oil_id, str):
            raise ValueError("oil_id must be a string")
        # arbitrary limit to catch ridiculous ones (UUIDs are 36 chars)
        self._validate_id(self.oil_id)

    def __str__(self):
        """
        need a custom str here, so we don't get a huge dump of the entire tree of data
        """
        return (f"{self.metadata.name}\n"
                f"ID: {self.oil_id}\n"
                f"Product Type: {self.metadata.product_type}"
                )

    # @property
    # def adios_data_model_version():
    #     return self._adios_data_model_version

    # @adios_data_model.setter:
    # def adios_data_model_version():

    @staticmethod
    def _pre_from_py_json(py_json):
        # check the version
        try:
            ver = py_json['adios_data_model_version']
            if Version.from_py_json(ver) != ADIOS_DATA_MODEL_VERSION:
                py_json = update_json_to_current_version(py_json)
                raise ValueError("Can't load this version of the data model")
            py_json.pop('adios_data_model_version', None)
        except KeyError:
            # not versioned, assume it will work
            pass
        return py_json

    @classmethod
    def from_file(cls, infile):
        """
        load an Oil object from the passed in JSON file

        it can be either a path or an open file object

        NOTE: this could be in the decorator -- but we only really need it
              for a full record.
        """
        try:
            py_json = json.load(infile)
        except AttributeError:
            # must not be an open file-like object
            py_json = json.load(open(infile, encoding='utf-8'))

        return cls.from_py_json(py_json)

    @staticmethod
    def _validate_id(id):
        if id == "":
            raise TypeError("You must supply a non-empty oil_id")
        elif not isinstance(id, str):
            raise ValueError("oil_id must be a string")
        # arbitrary limit to catch ridiculous onesL UUID is  36 characters
        elif len(id) > 40:
            raise ValueError("oil_id must be a string less than 40 characters in length")


    def validate(self):
        """
        validation specific to the Oil object itself

        validation of sub-objects is automatically applied
        """
        msgs = []

        # Validate ID
        try:
            self._validate_id(self.oil_id)
        except ValueError:
            msgs.append(ERRORS["E001"].format(self.oil_id))
        # always add these:
        msgs.extend("W000: " + m for m in self.permanent_warnings)
        return msgs

    def reset_validation(self):
        """
        calls the validate method, and updates the status with the result
        """
        msgs = self.validate()
        self.status = list(set(msgs))

    def to_file(self, infile):
        """
        save an Oil object as JSON to the passed in file

        it can be either a path or a writable open file object

        NOTE: this could be in the decorator -- but we only really need it
              for a full record.
        """
        try:
            json.dump(self.py_json(), infile)
        except AttributeError:
            # must not be an open file-like object
            json.dump(self.py_json(), open(infile, 'w', encoding='utf-8'), indent=4)

        return None

# fixme: this should probably go in a new file at some point
# fixme: make a Version type: maybe a namedtuple? is can save as a string
def update_json_to_current_version(py_json):
    """
    updates JSON for an oil object from an older version to a newer one
    """

    cur_ver = ADIOS_DATA_MODEL_VERSION
    ver = py_json.get('adios_data_model_version')

    if ver is None:
        # assume it's the version from before we added a version
        ver = "0.10.0"
    ver = Version.from_py_json(ver)
    if ver == cur_ver:  # nothing to be done
        return py_json
    elif ver > cur_ver:
        raise VersionError(f"Version: {ver} is not supported by this version of Oil object")
    else:
        raise VersionError(f"updator not available for version: {ver}")





