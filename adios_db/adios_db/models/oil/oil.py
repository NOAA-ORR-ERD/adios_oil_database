"""
Main class that represents an oil record.

This maps to the JSON used in the DB

Having a Python class makes it easier to write importing, validating etc, code.
"""
import json

from dataclasses import dataclass, field

from ..common.utilities import dataclass_to_json

from .metadata import MetaData
from .sample import SampleList

from .validation.warnings import WARNINGS
from .validation.errors import ERRORS


@dataclass_to_json
@dataclass
class Oil:
    oil_id: str  # required
    _id: str = ''

    metadata: MetaData = field(default_factory=MetaData)
    sub_samples: SampleList = field(default_factory=SampleList)
    status: list = field(default_factory=list)
    extra_data: dict = field(default_factory=dict)

    def __post_init__(self):
        '''
            Put any validation code here (__init__() is auto-generated by the
            dataclass decorator, and it will clobber any attempt to overload
            the __init__.)
        '''
        if self.oil_id == "":
            raise TypeError("You must supply a non-empty oil_id")
        elif not isinstance(self.oil_id, str):
            raise ValueError("oil_id must be a string")
        elif len(self.oil_id) > 64:  # arbitrary limit to catch ridiculous ones
            raise ValueError("oil_id must be a string less than 65 characters in length")
        else:
            self._id = self.oil_id

    def __str__(self):
        """
        need a custom str here, so we don't get a huge dump of the entire tree of data
        """
        return (f"{self.metadata.name}\n"
                f"ID: {self.oil_id}\n"
                f"Product Type: {self.metadata.product_type}"
                )

    @classmethod
    def from_file(cls, infile):
        """
        load an Oil object from the passed in JSON file

        it can be either a path or an open file object

        NOTE: this could be in the decorator -- but we only really need it
              for a full record.
        """
        try:
            py_json = json.load(infile)
        except AttributeError:
            # must not be an open file-like object
            py_json = json.load(open(infile, encoding='utf-8'))

        return cls.from_py_json(py_json)

    @staticmethod
    def _validate_id(id):
        if self.oil_id == "":
            raise TypeError("You must supply a non-empty oil_id")
        elif not isinstance(self.oil_id, str):
            raise ValueError("oil_id must be a string")
        elif len(self.oil_id) > 32:  # arbitrary limit to catch ridiculous ones
            raise ValueError("oil_id must be a string less than 32 characters in length")


    def validate(self):
        """
        validation specific to the Oil object itself

        validation of sub-objects is automatically applied
        """
        msgs = []

        # Validate ID
        if (not 0 < len(self.oil_id) <= 32
            or not isinstance(self.oil_id, str)):

            msgs.append(ERRORS["E001"].format(self.oil_id))

        return msgs

    def reset_validation(self):
        """
        calls the validate method, and updates the status with the result
        """
        msgs = self.validate()
        self.status = list(set(msgs))
        return msgs

    def to_file(self, infile):
        """
        save an Oil object as JSON to the passed in file

        it can be either a path or a writable open file object

        NOTE: this could be in the decorator -- but we only really need it
              for a full record.
        """
        try:
            json.dump(self.py_json(), infile)
        except AttributeError:
            # must not be an open file-like object
            json.dump(self.py_json(), open(infile, 'w', encoding='utf-8'), indent=4)

        return None





